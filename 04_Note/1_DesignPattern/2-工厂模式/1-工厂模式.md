- [1. **简单工厂模式**](#1-简单工厂模式)
  - [1.1 **简单工厂模式的定义**](#11-简单工厂模式的定义)
  - [1.2 **简单工厂模式的使用目的**](#12-简单工厂模式的使用目的)
  - [1.3 **简单工厂模式的实现方案**](#13-简单工厂模式的实现方案)
  - [1.4 **简单工厂模式的特点**](#14-简单工厂模式的特点)
- [2. **工厂方法模式**](#2-工厂方法模式)
  - [2.1 **工厂方法模式的定义**](#21-工厂方法模式的定义)
  - [2.2 **工厂方法模式的使用目的**](#22-工厂方法模式的使用目的)
  - [2.3 **工厂方法模式的实现方案**](#23-工厂方法模式的实现方案)
  - [2.4 **工厂方法模式的特点**](#24-工厂方法模式的特点)
    - [1) 优点](#1-优点)
    - [2) 缺点](#2-缺点)
  
工厂模式中包含:
- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式  
  
这三种模式,依次升级,简单工厂模式是工厂方法模式的基础,工厂方法模式又是抽象工厂模式的基础.

## 1. **简单工厂模式**

### 1.1 **简单工厂模式的定义**
> 定义一个工厂类,它根据不同的输入参数返回不同类的实例对象,被创建的这些实例通常拥有共同的父类,
### 1.2 **简单工厂模式的使用目的**
有时候用户不需要知道或者无法知道某个类的实例对象的创建过程,这个时候就将创建该实例的功能封装到一个工厂类中,用户通过向工厂类中传入相应的参数,就能获取到该参数对应的实例对象.

从设计原则上将,这也是对**职责单一原则**的贯彻,即:通过工厂类,将某个类的实例化和该类的实例对象的使用进行了分离.
### 1.3 **简单工厂模式的实现方案**
简单工厂模式的UML图:  
<div align=center>

![简单工厂模式类图](./简单工厂模式.drawio.svg)
</div>
由上图可以看出,简单工厂模式的实现方案由三个要点:  

- **工厂(Factory)**:在`factoryMethod()`中实现创建所有具体产品实例的逻辑, 返回类型为抽象产品类型`Product`
- **抽象产品(Product)**:抽象产品中定义了所有具体产品共有的方法和属性.
- **具体产品(ConcreteProduct)**:每一个具体产品都继承自抽象产品,并实现了抽象产品中所生命的各种方法.

```C++
#include <iostream>
#include <string>

typedef enum {
  TRUCK,
  CAR

} VehicleType;

// 抽象产品类: 车辆
class Vehicle {
public:
  Vehicle(){};
  ~Vehicle(){};

public:
  virtual void Run() = 0;                      // 车辆的共有方法:跑
  int NumberOfWheels() { return num_wheels_; } // 车辆的共有方法: 获取轮子的个数

protected:
  int num_wheels_; // 车辆的共有属性:轮子的个数
};

// 具体产品类: 货车
class TruckVehicle : public Vehicle {
public:
  TruckVehicle() {
    std::cout << "this is a truck!" << std::endl;
    num_wheels_ = 6;
  };
  ~TruckVehicle(){};

public:
  void Run() override; // 实现抽象产品类中声明的方法
};

void TruckVehicle::Run() {
  std::cout << "货车拉着货物跑!" << std::endl;
  return;
}

// 具体产品类: 轿车
class CarVehicle : public Vehicle {
public:
  CarVehicle() {
    std::cout << "this is a car!" << std::endl;
    num_wheels_ = 4;
  };
  ~CarVehicle(){};

public:
  void Run() override; // 实现抽象产品类中声明的方法
};

void CarVehicle::Run() {
  std::cout << "轿车拉着人跑!" << std::endl;
  return;
}

// 工厂类
class VehicleFactory {
public:
  VehicleFactory(){};
  ~VehicleFactory(){};

public:
  Vehicle *GenerateVehicle(const VehicleType &vehicle_type);
};

Vehicle *VehicleFactory::GenerateVehicle(const VehicleType &vehicle_type) {
  Vehicle *vehicle_ptr = nullptr;
  switch (vehicle_type) {
  case TRUCK:
    vehicle_ptr = new TruckVehicle();
    break;
  case CAR:
    vehicle_ptr = new CarVehicle();
    break;
  default:
    std::cout << "this type: " << vehicle_type << " is not existed!";
    break;
  }
  return vehicle_ptr;
}

int main(int, char **) {
  auto factory = VehicleFactory();
  VehicleType type1 = TRUCK;
  auto vehicle1 = factory.GenerateVehicle(type1);
  vehicle1->Run();
  std::cout << "Number of Wheels is : " << vehicle1->NumberOfWheels()
            << std::endl;

  VehicleType type2 = CAR;
  auto vehicle2 = factory.GenerateVehicle(type2);
  vehicle2->Run();
  std::cout << "Number of Wheels is : " << vehicle2->NumberOfWheels()
            << std::endl;

  return 0;
}
```
输出为:
```
this is a truck!
货车拉着货物跑!
Number of Wheels is : 6
this is a car!
轿车拉着人跑!
Number of Wheels is : 4
```
简单工厂模式的实现主要是实现**工厂类**,**抽象产品类**和**具体产品类**.如上例中,`VehicleFactory`是工厂类,`Vehicle`是抽象产品类,`TruckVehicle`和`CarVehicle`都是具体的产品类.
### 1.4 **简单工厂模式的特点**
从上面的例子我们也可以看出:  
- 如果想要再增加一种类型的车辆:客车,那么除了新增一个`BusVehicle`类之外,还需要在`VehicleFactory`中再增加一个case条件.这显然违背了**对扩展开放,对修改关闭**的原则,因为修改了`VehicleFactory`中的代码.  
- 此外如果具体的产品类非常多的化,那么在工厂类中创建具体产品类的实例时,会有很多的分支,导致工厂类过于庞大.  
  
为了解决以上两个缺点,又引入了**工厂方法模式**.

## 2. **工厂方法模式**
### 2.1 **工厂方法模式的定义**
> 在抽象工厂类中定义一个用于创建产品类实例的接口,但是让抽象工厂类的子类去决定将哪个具体产品类实例化.这样就将一个具体产品类的实例化过程推迟到抽象工厂类的子类去实现
### 2.2 **工厂方法模式的使用目的**
在简单工厂模式中,每增加一个新的具体产品,都需要修改工厂类中的代码,这就违反了开闭原则.为了不用修改工厂类,遵循开闭原则,工厂方法模式中,不再通过工厂类创建所有的具体产品,而是针对不同的具体产品,设计不同的具体工厂,每一个具体工厂只生产一种具体产品.

### 2.3 **工厂方法模式的实现方案**
工厂方法模式的UML图:  
<div align=center>

![工厂方法模式类图](./工厂方法模式.drawio.svg)
</div>
从上图中可以看出,工厂方法模式中有四种角色:  

- **抽象工厂(AbstractFactory)**:定义了创建一个产品实例的接口,以及所用具体工厂的共有方法和属性,是所有具体工厂类的父类;
- **具体工厂(ConcreteFactory)**:实现了抽象工厂中定义的创建产品实例的借口;
- **抽象产品(AbstractProduct)**:是所有具体产品的父类,并且定义了所有产品的共有行为和属性
- **具体产品(ConcreteProduct)**:实现了抽闲产品中所定义的共有行为

```C++
#include <iostream>
#include <string>

typedef enum {
  TRUCK,
  CAR,
  BUS

} VehicleType;

// 抽象产品类: 车辆
class Vehicle {
public:
  Vehicle(){};
  ~Vehicle(){};

public:
  virtual void Run() = 0;                      // 车辆的共有方法:跑
  int NumberOfWheels() { return num_wheels_; } // 车辆的共有方法: 获取轮子的个数

protected:
  int num_wheels_; // 车辆的共有属性:轮子的个数
};

// 具体产品类: 货车
class TruckVehicle : public Vehicle {
public:
  TruckVehicle() {
    std::cout << "this is a truck!" << std::endl;
    num_wheels_ = 6;
  };
  ~TruckVehicle(){};

public:
  void Run() override; // 实现抽象产品类中声明的方法
};

void TruckVehicle::Run() {
  std::cout << "货车拉着货物跑!" << std::endl;
  return;
}

// 具体产品类: 轿车
class CarVehicle : public Vehicle {
public:
  CarVehicle() {
    std::cout << "this is a car!" << std::endl;
    num_wheels_ = 4;
  };
  ~CarVehicle(){};

public:
  void Run() override; // 实现抽象产品类中声明的方法
};

void CarVehicle::Run() {
  std::cout << "轿车拉着人跑!" << std::endl;
  return;
}

// 具体产品类: 客车
class BusVehicle : public Vehicle {
public:
  BusVehicle() {
    std::cout << "this is a bus!" << std::endl;
    num_wheels_ = 4;
  };
  ~BusVehicle(){};

public:
  void Run() override; // 实现抽象产品类中声明的方法
};

void BusVehicle::Run() {
  std::cout << "客车拉着乘客跑!" << std::endl;
  return;
}


// 抽象工厂类
class AbstractVehicleFactory {
public:
  AbstractVehicleFactory(){};
  ~AbstractVehicleFactory(){};

public:
  virtual Vehicle *GenerateVehicle(const VehicleType &vehicle_type) = 0; // 定义创建产品实例的接口
};

// 具体工厂类: 货车厂
class TruckVehicleFactory : public AbstractVehicleFactory
{
public:
  TruckVehicleFactory(){
    std::cout << "this is a truck factory!" << std::endl;
  };
  ~TruckVehicleFactory(){};
public:
  Vehicle* GenerateVehicle(const VehicleType& vehicle_type) override; // 实现创建产品实例的接口
};

Vehicle* TruckVehicleFactory::GenerateVehicle(const VehicleType& vehicle_type){
  return new TruckVehicle();
}

// 具体工厂类: 轿车厂
class CarVehicleFactory : public AbstractVehicleFactory
{
public:
  CarVehicleFactory() {
    std::cout << "this is a car factory!" << std::endl;
  };
  ~CarVehicleFactory(){};
public:
  Vehicle* GenerateVehicle(const VehicleType& vehicle_type) override;// 实现创建产品实例的接口
};

Vehicle* CarVehicleFactory::GenerateVehicle(const VehicleType& vehicle_type){
  return new CarVehicle();
}

// 具体工厂类: 客车厂
class BusVehicleFactory : public AbstractVehicleFactory
{
public:
  BusVehicleFactory() {
    std::cout << "this is a bus factory!" << std::endl;
  };
  ~BusVehicleFactory(){};
public:
  Vehicle* GenerateVehicle(const VehicleType& vehicle_type) override;// 实现创建产品实例的接口
};

Vehicle* BusVehicleFactory::GenerateVehicle(const VehicleType& vehicle_type){
  return new BusVehicle();
} 

int main(int, char **) {
  AbstractVehicleFactory* factory = nullptr;
  Vehicle* vehicle = nullptr;

  VehicleType type1 = TRUCK;
  factory = new TruckVehicleFactory();
  vehicle = factory->GenerateVehicle(type1);
  vehicle->Run();
  std::cout << "Number of Wheels is : " << vehicle->NumberOfWheels()
            << std::endl;

  VehicleType type2 = CAR;
  factory = new CarVehicleFactory();
  vehicle = factory->GenerateVehicle(type2);
  vehicle->Run();
  std::cout << "Number of Wheels is : " << vehicle->NumberOfWheels()
            << std::endl;

  VehicleType type3 = BUS;
  factory = new BusVehicleFactory();
  vehicle = factory->GenerateVehicle(type3);
  vehicle->Run();
  std::cout << "Number of Wheels is : " << vehicle->NumberOfWheels()
            << std::endl;

  return 0;
}
```
输出为:
```
this is a truck factory!
this is a truck!
货车拉着货物跑!
Number of Wheels is : 6
this is a car factory!
this is a car!
轿车拉着人跑!
Number of Wheels is : 4
this is a bus factory!
this is a bus!
客车拉着乘客跑!
Number of Wheels is : 4
```
### 2.4 **工厂方法模式的特点**
#### 1) 优点
#### 2) 缺点